clear all;% FFT lengthfft_len = 64;% guard_lenuard lengthguard_len = fft_len / 4;% Modulation orderm_ary = 16;% Number of symbolsno_of_syms = 100;rho = [1, 0.6095, 0.4945, 0.3940, 0.2371, 0.19, 0.1159, 0.0699];n_p = length (rho);% The length of the input bit sequencedata_len = no_of_syms * fft_len;% guard_lenenerating random bit sequence in matrix forminput_bit_seq = randi ([0 1], data_len, sqrt (m_ary));% Converting each row of the matrix to decimal valueinput_dec_seq = zeros (1, data_len);for i = 1:data_len	input_dec_seq(i) = bi2de (input_bit_seq(i, :));end % End of bi2de loop% Putting source data through the PSK Modulatormodulated_data = pskmod (input_dec_seq, m_ary, 0, 'gray');% Implementing ICI canceling modulationici_modulated_data = zeros (1, (data_len * 2));indx_ici = 1;for j = 1:2:(data_len * 2)	ici_modulated_data(j) = modulated_data(indx_ici);	ici_modulated_data(j + 1) = -(modulated_data(indx_ici));	indx_ici = indx_ici + 1; end % End of ICI canceling modulation loop% N-point IFFT implementation on ICI SC dataN = fft_len;data_ifft = zeros (N, no_of_syms * 2);indx_ff = 0;for i = 1:(no_of_syms * 2)    for j = 1:N        data_ifft(j, i) = ici_modulated_data(indx_ff + j);    end % End of ICI SC data's row crawling loop        indx_ff = indx_ff + fft_len;end % End of IFFT loopifft_data = ifft (data_ifft, fft_len, 1);% N-point IFFT implementation on conventional dataN = fft_len;data_ifft_con = zeros (N, no_of_syms);indx_ff_con = 0;for i = 1:no_of_syms    for j = 1:N       data_ifft_con(j, i) = modulated_data(indx_ff_con + j);     end % End of conventional data's row crawling loopendifft_con_data = ifft (data_ifft_con, fft_len, 1);% Adding guard to ifft_dataguarded_data = vertcat (ifft_data((end - (guard_len - 1)):end, :), ifft_data);% Adding guard to ifft_data_conguarded_con_data = vertcat (ifft_con_data((end - (guard_len - 1)):end, :), ifft_con_data);% Parametereceived_data for Monte Carlo channelno_of_realizations = 50;no_of_sums = 40;t_a = 50 * 10^(-9);sym_duration = fft_len * t_a;f_dmax = 50;% Channel simulationsnr_min = 0;snr_max = 35;step = 1;received_data_frame = zeros ((fft_len + guard_len + n_p - 1), (no_of_syms * 2));received_con_data_frame = zeros ((fft_len + guard_len + n_p - 1), no_of_syms);h_frame = zeros ((no_of_syms * 2), n_p);ser_relz = zeros (no_of_realizations, ((snr_max - snr_min) / step) + 1);ser_relz_con = zeros (no_of_realizations, ((snr_max - snr_min) / step) + 1);for n_r = 1:no_of_realizations;    u = rand (n_p, no_of_sums);        % A random variable for Monte-Carlo method    ser_per_snr = zeros (1, ((snr_max - snr_min) / step) + 1);    ser_per_snr_con = zeros (1, ((snr_max - snr_min) / step) + 1);        for snr = snr_min:step:snr_max;        snr_ = snr - 10 * log10 ((fft_len + guard_len) / fft_len);                % Miss matching effect caused by using guard interval        initial_time = 0;                % Convolutional operation on ICI SC data        for i = 1:(no_of_syms * 2);            [h, t] = MCM_channel_model (u, initial_time, no_of_sums, sym_duration, f_dmax, rho);            h_frame(i, :) = h;                        % Received signal over multipath channel by convolutional operation            received_data = conv (guarded_data(:, i), h);                        % Adding additive noise            received_data = awgn (received_data, snr_, 'measured', 'dB');                        received_data_frame(:, i) = received_data;            initial_time = t;        end;  % End of ICI SC data's convolution loop                % Convolutional operation on conventional data        for i = 1:no_of_syms;            [h, t] = MCM_channel_model (u, initial_time, no_of_sums, sym_duration, f_dmax, rho);            h_frame(i, :) = h;                        % Received signal over multipath channel by convolutional operation            received_con_data = conv (guarded_con_data(:, i), h);                        % Adding additive noise            received_con_data = awgn (received_con_data, snr_, 'measured', 'dB');                        received_con_data_frame(:, i) = received_con_data;            initial_time = t;        end;  % End of conventional data's convolution loop            % TODO - SER calculation for each value of SNR from min to max        % ISI simulation on ICI SC data        for i = 1:(no_of_syms * 2);            if (n_p > guard_len + 1) && (i > 1)                previous_symbol = received_data_frame(:, i-1);                isi_term = previous_symbol(fft_len+guard_len+n_p-1:fft_len+2*guard_len+1);                isi = [isi_term, zeros(1,length (previous_symbol) - length (isi_term))];                received_data_frame(:, i) = received_data_frame(:, i) + ISI;            end; % End of guard length check statement                    end; % End of ICI SC data's ISI simulation loop        % ISI simulation on conventional data        for i = 1:no_of_syms;            if (n_p > guard_len + 1) && (i > 1)                previous_con_symbol = received_con_data_frame(:, i-1);                isi_term = previous_con_symbol(fft_len+guard_len+n_p-1:fft_len+2*guard_len+1);                isi = [isi_term, zeros(1,length (previous_con_symbol) - length (isi_term))];                received_con_data_frame(:, i) = received_con_data_frame(:, i) + ISI;            end; % End of guard length check statement                    end; % End of conventional data's ISI simulation loop                % ICI SC signal retrieving        processed_data = zeros ((fft_len + guard_len), (no_of_syms * 2));        for i = 1:(no_of_syms * 2)            h_freq = fft ([h_frame(i, :), zeros(1, fft_len+guard_len-1)]);            h_freq_trans = transpose (h_freq);            processed_col = received_data_frame(:, i) ./ h_freq_trans;            processed_col = processed_col(1:(fft_len + guard_len));            processed_data(:, i) = processed_col;        end % End of ICI SC signal retrieving loop                % Conventional signal retrieving        processed_con_data = zeros ((fft_len + guard_len), no_of_syms);        for i = 1:no_of_syms            h_freq_con = fft ([h_frame(i, :), zeros(1, fft_len+guard_len-1)]);            h_freq_con_trans = transpose (h_freq_con);            processed_con_col = received_con_data_frame(:, i) ./ h_freq_con_trans;            processed_con_col = processed_con_col(1:(fft_len + guard_len));            processed_con_data(:, i) = processed_con_col;        end % End of conventional signal retrieving loop                % Removing guard        offguarded_data = processed_data((end - (fft_len - 1)):end, :);        offguarded_con_data = processed_con_data((end - (fft_len - 1)):end, :);        % N-point FFT implementation with N equals 64        fft_data = fft (offguarded_data, N, 1);        fft_con_data = fft (offguarded_con_data, N, 1);        % Implementing ICI canceling demodulation        ici_demodulated_data = zeros (1, data_len);        indx_ici = 1;        for j = 1:2:(data_len * 2)            ici_demodulated_data(indx_ici) = fft_data(j);            indx_ici = indx_ici + 1;        end % End of ICI canceling demodulation loop        % Putting ICI demodulated data through PSK Demodulator        demodulated_data = pskdemod (ici_demodulated_data, m_ary, 0, 'gray');                % PSK demodulating conventional data        con_data = reshape (fft_con_data, [1, data_len]);        demodulated_con_data = pskdemod (con_data, m_ary, 0, 'gray');        % Converting output decimal values to binary rows        output_bit_seq = de2bi (demodulated_data);        output_con_bit_seq = de2bi (demodulated_con_data);        %output_bit_seq = vec2mat (output_de2bi_seq, 4);                % SER calculation for ICI SC data        [no_of_symerrs, ser_val] = symerr (input_dec_seq, demodulated_data);        ser_per_snr(snr + 1) = ser_val;                % SER calculation for conventional data        [no_of_symerrs_con, ser_val_con] = symerr (input_dec_seq, demodulated_con_data);        ser_per_snr_con(snr + 1) = ser_val_con;    end;  % End of SNR increment loop      % SER values gathering for every realization    ser_relz(n_r, :) = ser_per_snr;    ser_relz_con(n_r, :) = ser_per_snr_con;    end;  % End of realization increment loopSER = sum(ser_relz) / no_of_realizations;SNR = snr_min:step:snr_max;SER_con = sum(ser_relz_con) / no_of_realizations;SNR_con = snr_min:step:snr_max;semilogy (SNR, SER, '*-r', SNR_con, SER_con, ':b');legend ('ICI Self-Cancelation System', 'Conventional System');hold on    ylabel('SER');xlabel('SNR in dB');% a = output_bit_seq - input_bit_seq;% if nnz (a) == 0%     disp ('a ~ all zero');% end% % b = demodulated_data - input_dec_seq;% if nnz (b) == 0%     disp ('b ~ all zero');% end% % c = ici_demodulated_data - modulated_data;% if nnz (c) == 0%   disp ('c ~ all zero');% end% % d = fft_data - ici_modulated_data;% if nnz (d) == 0%   disp ('d ~ all zero');% end% % e = offguarded_data - ifft_data;% if nnz (e) == 0%   disp ('e ~ all zero');% end% % f = processeded_data - guarded_data;% if nnz (f) == 0%   disp ('f ~ all zero');% end